package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.30

import (
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"strconv"

	"github.com/kenya6565/pokemon_pokedex/graph/model"
)

// Pokemon is the resolver for the pokemon field.
func (r *queryResolver) Pokemon(ctx context.Context, id string) (*model.Pokemon, error) {
	panic(fmt.Errorf("not implemented: Pokemon - pokemon"))
}

// Pokemons is the resolver for the pokemons field.
func (r *queryResolver) Pokemons(ctx context.Context, limit *int, offset *int) ([]*model.Pokemon, error) {
	if limit == nil {
		defaultLimit := 20
		limit = &defaultLimit
	}
	if offset == nil {
		defaultOffset := 0
		offset = &defaultOffset
	}

	url := fmt.Sprintf("https://pokeapi.co/api/v2/pokemon?limit=%d&offset=%d", *limit, *offset)
	resp, err := http.Get(url)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	var data map[string]interface{}
	if err := json.Unmarshal(body, &data); err != nil {
		return nil, err
	}

	// make list from json data including pokeAPI
	results := data["results"].([]interface{})
	pokemons := make([]*model.Pokemon, len(results))
	for i, r := range results {
		result := r.(map[string]interface{})
		// convert id type into int with atrconv.Atoi
		id, _ := strconv.Atoi(result["url"].(string)[34 : len(result["url"].(string))-1])
		pokemons[i] = &model.Pokemon{
			ID:   fmt.Sprint(id),
			Name: result["name"].(string),
		}
	}

	return pokemons, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
